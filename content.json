{"pages":[],"posts":[{"title":"深入理解Grand Central Dispatch:第一部分","text":"尽管Grand Central Dispatch（简称GCD） 很早就已经使用，但并不是每个人都了解如何充分使用它们。棘手的并发处理和一堆基于C指针的GCD开发文文档，似乎与Objective-C通常表达形式格格不入。本篇教程将分两部分更深一步学习GCD。 第一部分主要是学习什么是GCD，了解GCD的一些基本功能。第二部分我们将学习GCD提供的更为高级的功能。 什么是GCDGCD是libdispatch（是苹果公司支持并发执行的多核处理机器中iOS和OS X系统上的一个类库）的别称。它具有以下特性： GCD可以显著提高程序的响应速度，使那些消耗较多资源的计算在后台运行。 GCD提供了一种比锁和线程更加容易处理的并发模型，并且有效地避免了并发错误。 GCD可以通过一些原语性的通用模型来提高我们的代码质量，如单例模式。本篇教程假定您已经对Block和GCD有了基本的了解，如果还不是那么清楚，可以阅读下这篇教程Multithreading and Grand Central Dispatch on iOS for Beginners GCD相关术语要想理解GCD，你需要对线程和并发相关概念相当熟悉。所以在深入学习GCD之前我们先重温下关于线程和并发的概念。 串行和并行串行和并行描述了不同任务在执行时的一种相互关系。多任务可以顺序执行，也可以同一时间同时执行。 尽管串行和并行已经有了广泛的应用，但是在本篇教程我们把一个任务当成Objective-C block或许会更好理解。更多块语法相关知识请查看这篇文章How to Use Blocks in iOS 5 Tutorial。事实上，你可以把GCD当成一种函数指针，但是大多数情况GCD比Block在实际运用中会更加麻烦。 同步与异步在GCD中，同步和异步描述一个函数的完成是依赖于其中使用GCD来完成任务的情况。一个同步执行的函数只有在任务按顺序完成时才会返回。 对于异步函数，不会等到顺序任务完成之后返回，而是会立即返回。因此，一个异步函数不会阻塞当前进程而回继续执行下一个函数。 请注意，当你读到同步函数阻塞当前进程时，不要混淆该函数是个“blocking”函数还是blocking（阻塞）操作。前面的blocks是描述这个函数是否阻塞当前线程，而和block语法没有什么关系（这里的block语法是指Objective-C中定义的匿名函数和提交给GCD来执行的一个任务。也就是说block在英语中有两种意思一种是阻塞的意思，另外一个就是Objective-C Block的专有名词称为块语法）。 临界区每个线程中访问临界资源的那段代码称为临界区，也就是说这段代不能被两个线程同时访问。这通常是由于代码共享同一资源引起的，例如并发进程访问同一个变量，可能会使这个数据变为脏数据。 死锁不同线程因相互等待对方完成而进行下一步操作的现象称为死锁。第一个线程无法完成是因为它在等待第二个线程的完成，而第二个线程却在等待第一个线程的完成。 线程安全线程安全是指代码可以被不同线程或者并发任务唤起而不会造成任何问题（如数据损坏，程序崩溃等）。非线程安全是指代码只允许同一时间在同一个上下文执行。例如NSDictionary就是线程安全的，你可以在同一时间的多个线程调用而不会产生任何问题。然而对于NSMutableDictionary却不是线程安全的，在每一时刻只能运行在一个线程中。 上下文切换上下文切换是指在一个单独进程中进行不同线程的切换，存储和恢复之前执行的一种状态的过程。这个过程在多任务处理的程序中是相当普遍的，但是会消耗额外的资源。 并发与并行并发与并行经常会被同时提起，所以有必要对这两个概念进行区分。 并发代码的不同部分可以被同时执行，这是由系统决定的。多核设备可以在同一时间并行执行多个线程，然而在单核系统上只能执行单个线程，所以为了达到这种效果，只能通过上下文切换来执行另外一个线程，这通常是发生在极短时间内的，所以会给人一种并发的假象，如下图所示： 尽管你可以通过GCD来实现并发执行，但是会有多少并行却是由GCD来决定的。并行决定着并发，但是并发却不能保证并行。从深层次来看，并发是架构层面的。当你使用GCD来架构代码时，你可以对代码进行并发处理，也可以不那么做。如果想更深入了解这方面的知识请浏览 this excellent talk by Rob Pike. 队列GCD提供调度队列（dispatch queues）来处理代码块，这些队列管理着你提供给GCD的任务并按照先进先出（FIFO）的顺序执行。这就保证了添加到队列中的任务是按照顺序执行的。 所有的调度队列都是线程安全的，所以你可以同时在多个线程执行调度队列。当你明白了调度队列如何保证你的代码线程安全时，你会发现GCD是很好用的。把你的任务提交到队列的关键是选择合适的调度队列和正确的调度功能。 在这部分教程中，你将了解到两种由GCD支持的队列调度方式，然后通过一些例子了解如何通过GCD将任务添加到调度队列中。 串行队列在串行队列每次只执行一个任务，每个任务只有在前一个任务结束时才能够执行。同时，你无法确定这个块结束和下一个开始之间的时长，如下图所示： 这些任务的执行时间是由GCD来控制的，唯一能够确定的是GCD每次只执行一个任务并且会按照进队顺序执行。由于串行队列中两个任务不能同时运行，所以没有同时访问临界区的风险。这就可以保证这些任务避免资源竞争。所以如果访问临界区的唯一途径就是将任务提交到调度队列中，那么你就可以保证临界区是安全的。 并发队列并发进程能够保证任务按照进队顺序执行，但无法保证按照进队顺序结束的，同时也不知道什么时候执行下一个快或者每个块执行所需时间。因为这些都是由GCD决定的。下图展示了在GCD下四个并发任务执行的情况： 上图描述了一个块的开始是由GCD来决定的。如果一个块的执行时间与另外一个重叠，那么GCD会决定是在不同的内核上运行，还是通过上下文切换在同一个可用内核上并发运行。 为了变得更有趣，GCD提供了至少5种队列类型以供选择。 队列类型首先，系统提供了一个被称为主队列(main queue)的特殊队列，像串行队列一样，每次只执行一个任务。然而，主队列会保证每个任务是在主线程中执行的，主线程是唯一一个允许你执行界面更新的一个线程。这个线程可以给UIViews发送消息或者通知。 系统同样提供了几个并发队列。这些队列被称作全局调度队列（Global Dispatch Queues）。目前有四个不同级别的全局队列分别为：background, low, default, 和 high。请注意苹果的API也会使用这些队列，所以这些队列中不会仅仅只有你添加的任务。 最后，你也可以创建属于你自己的串行或者并行队列。这就意味着你至少可以使用五种不同类型的队列：主队列和四种不同类型的全局队列，另外还有更多自定义的队列可供选择。使用GCD的关键是将任务添加到合适的队列调度中来执行。你可以通过下面建议的通常方法来获得最佳的实践经验。 开始这篇教程的目的是通过GCD在不同的线程安全调用所写的代码，我们以一个完成的项目GooglyPuff来开始下面的教程。 GooglyPuff 是一个未经过优化的，线程不安全的应用程序，这个程序主要通过Core Image API检测人脸,并在眼睛上放个曲棍球。对于所检测的图片既可以从本地图片库选取也可以从网络上下载。 点击这里下载应用源码。 下载源码，打开并运行程序会如下图所示： 当你点击Le Internet下载图片时，一个UIAlertView弹出框会过早的弹出。在第二部分教程我们将修复这个问题。在这个项目中有四个类： PhotoCollectionViewController:这是应用程序启动时的第一个视图控制器，它通过缩略图展示了所有选定的图片。 PhotoDetailViewController:这个类执行将类似曲棍球的眼睛添加到图像上相关逻辑，并展示到UIScrollView上面。 Photo:这是一个与NSURL和ALAsset实例相关的图片类簇。这个类提供图像，缩略图和从网络获取图片的下载状态。PhotoManager:这个类管理与Photo相关的所有实例。 通过dispatch_sync处理后台任务回到应用程序，从图片库添加一些图片或者使用Le Internet下载一些图片。 请注意在PhotoCollectionViewController中点击UICollectionViewCell时需要花费较长时间来实例化一个新的PhotoDetailViewController。尤其在一个速度慢的机器上打开一张较大的图片时会有明显的滞后。但是这很容易加载UIViewController’s viewDidLoad一些冗余的东西。这就导致在页面出现之前会有一个明显的停滞问题。如果可以的话最好在后台完成一些在页面加载时不必要的操作。 打开PhotoDetailViewController并用下面的代码替换viewDidLoad中的内容 1234567891011121314151617- (void)viewDidLoad{ [super viewDidLoad]; NSAssert(_image, @\"Image not set; required to use view controller\"); self.photoImageView.image = _image; //Resize if neccessary to ensure it's not pixelated if (_image.size.height &lt;= self.photoImageView.bounds.size.height &amp;&amp; _image.size.width &lt;= self.photoImageView.bounds.size.width) { [self.photoImageView setContentMode:UIViewContentModeCenter]; }dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ // 1 UIImage *overlayImage = [self faceOverlayImageFromImage:_image]; dispatch_async(dispatch_get_main_queue(), ^{ // 2 [self fadeInNewImage:overlayImage]; // 3 }); });} 为什么这样修改： 首先把主线程中的操作放到全局队列中。因为这是一个dispatch_async()，所以异步提交这个块意味着使用线程来继续执行。这使viewDidLoad在主线程更快返回，使页面加载更顺畅。同时，人脸检测操作会在稍后开始并完成。 此时，人脸检测完成并生成一张新的图片。既然想把这张新的图片更新到UIImageView，那么就需要在主线程添加一个新的块操作。请记住必须在主线程操作UI Kit classes。 最后，你需要通过fadeInNewImage:更新界面来渐变显示一张带有曲棍球眼睛的图片。 编译并运行程序，选择一张图片你会发现视图控制器明显加载更快了，在短时间延迟后添加上了曲棍球眼睛。照片前后不同的显示带来了不错的视觉冲击。还有，如果你尝试加载一张巨大的图片，应用程序不会在加载过程中挂起，这就使应用能够进行更好的进行扩展了。 如上所述，dispatch_async附加一个块到队列中并立即返回。该任务会由GCD来决定何时执行。使用dispatch_async在后台执行基于网络的或者CPU密集型任务而不会去阻塞主线程。 以下是在何时及如何使用dispatch_async各种队列类型的快速指南： Custom Serial Queue:当需要在后台跟踪不断执行的任务时可以使用此类型队列。因为一次只执行一个任务，所以就避免了资源竞争。需要注意的是，如果你需要获取一个方法的返回值，你必须内嵌另外一个块去返回数据或者考虑使用dispatch_sync。 Main Queue (Serial):当一个任务在并发线程完成时，通常会选择主线程去更新页面显示，为了做到这一点你需要将一个块嵌到另外一个中。还有，如果在线程中调用了dispatch_async，你需要保证这个异步任务会在主线程完成之后不久去执行。 Concurrent Queue:通常在后台去执行不需要更新页面的任务时会使用并发线程。 使用dispatch_after延迟任务执行考虑一下你的应用的用户体验。用户在第一次打开程序的时候是否对如何使用这个应用而感到困惑。 如果在PhotoManager没有找到任何图片，这时给用户一个提醒或许是个好主意。不过，你同时需要注意，如果提醒时间过短的话，用户可能会因为浏览导航界面的其他部分而错过这个提醒。当用户第一次浏览应用时，延迟一秒去显示提醒或许已经足够引起用户注意。 将下列代码添加到PhotoCollectionViewController.m文件的showOrHideNavPrompt方法中: 12345678910111213- (void)showOrHideNavPrompt{ NSUInteger count = [[PhotoManager sharedManager] photos].count; double delayInSeconds = 1.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 if (!count) { [self.navigationItem setPrompt:@\"Add photos with faces to Googlyify them!\"]; } else { [self.navigationItem setPrompt:nil]; } });} showOrHideNavPrompt方法在viewDidLoad中执行并会在UICollectionView加载时执行。如下列步骤所示： 首先声明指定时间延迟的变量。 然后等待delayInSeconds一段时间后将同步代码块添加到主线程中。 编译并运行程序，等待一会儿会出现一个用户如何进行操作的提示。dispatch_after就像一个dispatch_async延迟操作。但是仍然无法获取这个块执行的时间并且没办法在dispatch_after返回时取消相应操作。 思考下在何种情况下使用dispatch_after较好？ Custom Serial Queue:在自定义队列使用dispatch_after要小心，最好将这个操作在主队列执行。 Main Queue (Serial):推荐在主队列中使用dispatch_after，Xcode有一个很好的宏定义来使用此方法。 Concurrent Queue:在并发队列中使用dispatch_after要十分注意，需要始终在主队列中进行相关操作。 确保单例线程安全单例，不管喜欢还是讨厌，在iOS中就是这么流行。一个经常担心的问题是单例是不是线程安全的。单例通常会在同一时间被不同的视图控制器访问。单例的线程安全问题包括初始化，读取和写入数据。 PhotoManager就是通过单例来实现的——它同样会受到上述问题影响。你将很快看到问题的出现。 切换到PhotoManager.m类中，找到sharedManager方法，如下面代码所示 123456789+ (instancetype)sharedManager{ static PhotoManager *sharedPhotoManager = nil; if (!sharedPhotoManager) { sharedPhotoManager = [[PhotoManager alloc] init]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; } return sharedPhotoManager;} 这段代码看起来相当简单，创建一个单例，并初始化一个NSMutableArray类型的私有变量photosArray。 然而，if分支不是线程安全的。如果你多次调用这个方法，很有可能A线程在进入if代码块中并在sharedPhotoManager初始化前，此时B线程进入if中并进行了初始化，然后退出。当系统切换到A线线程时，B线程依然会继续生成另外一个单例，然后退出。这时系统就会同时拥有两个单例而不清楚到底使用哪一个。 为了实现这种效果，使用下面的带面替换PhotoManager.m类中的sharedManager方法： 123456789101112+ (instancetype)sharedManager{ static PhotoManager *sharedPhotoManager = nil; if (!sharedPhotoManager) { [NSThread sleepForTimeInterval:2]; sharedPhotoManager = [[PhotoManager alloc] init]; NSLog(@\"Singleton has memory address at: %@\", sharedPhotoManager); [NSThread sleepForTimeInterval:2]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; } return sharedPhotoManager;} 在上边代码中你需要使用NSThread’s sleepForTimeInterval:方法来强制进行上下文切换。打开AppDelegate.m文件并将下面的代码添加到application:didFinishLaunchingWithOptions:方法中： 123456dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ [PhotoManager sharedManager];});dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ [PhotoManager sharedManager];}); 这将创建多个异步并发线程，同时调用单例初始化方法并出现上边所述的竞争关系。编译并运行项目，查看控制窗口输出，你会看到多个不同的单例，如下图所示： 上图不同地址的单例是不是已经违背了单例的初衷了呢；上边的输出显示本应该只执行一次的临界区域被访问了多次。我们强制了这种情况的发生，但是你可以想象一下这种情况在现实中是如何发生的。 注意:上述NSLogs是在特定条件下展示的，基于其他系统时间是不可控的，所以当发生线程问题时是很难追踪并重现该问题的。 为了避免这种情况的发生，初始化代码必须只执行一次并且阻止其他情况下的初始化行为，所以if条件的修改是关键。这正是dispatch_once所应该做的。使用dispatch_once来代替if语句的初始化如下面代码所示： 12345678910111213+ (instancetype)sharedManager{ static PhotoManager *sharedPhotoManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ [NSThread sleepForTimeInterval:2]; sharedPhotoManager = [[PhotoManager alloc] init]; NSLog(@\"Singleton has memory address at: %@\", sharedPhotoManager); [NSThread sleepForTimeInterval:2]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; }); return sharedPhotoManager;} 编译并运行程序，查看输出窗口你会发现只有一个初始化地址的单例，这正是我们所想要的单例。 现在你明白了防止资源竞争的重要性了，在AppDelegate.m去掉dispatch_async代码，并用下边的代码初始化PhotoManager‘s单例： 12345678910+ (instancetype)sharedManager{ static PhotoManager *sharedPhotoManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedPhotoManager = [[PhotoManager alloc] init]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; }); return sharedPhotoManager;} dispatch_once()以一种线程安全的方式执行且只执行一次代码块。当不同的线程尝试访问这个临界区时，此时临界区中的线程会阻止其他线程访问，并且直到完成初始化操作之后才会允许其他线程操作。 值得注意的是我们仅仅让共享的实例线程安全而已，而并没有使整个类线程安全。在这个类中肯定还有其他的临界区，例如同步访问数据的地方，这些地方也应该是线程安全的。接下来我们将学习这一部分。 处理读与写的问题线程安全不仅仅是处理单例时的问题。如果在单例属性中有个可变的对象，那么同样也需要考虑这个对象的线程安全问题。 系统自带的类库中的类是否会有线程安全问题，答案是可能会有。苹果文档中列出了很多非线程安全的基础类，例如上面提到的NSMutableArray类型。 尽管很多线程可以同时读取NSMutableArray而不会产生什么问题，但是如果一个线程读，一个线程写入可能就会造成线程的不安全。你当前的单例并没有预防这种情况的发生。打开PhotoManager.m，查看addPhoto:方法： 123456789- (void)addPhoto:(Photo *)photo{ if (photo) { [_photosArray addObject:photo]; dispatch_async(dispatch_get_main_queue(), ^{ [self postContentAddedNotification]; }); }} 这是一个写操作，改变了私有数组的值。现在看下photos方法： 1234- (NSArray *)photos{ return [NSArray arrayWithArray:_photosArray];} 这是一个从可变数组读取数据的方法。这个方法为调用者生成一个不可变的副本以防止对可变数组不恰当的访问。但是该方式并没有阻止一个线程在addPhoto:写入，另外一个并发线程从photos读取数据。这是一个经典的读者写者问题Readers-Writers Problem。GCD提供了一种优雅的解决方案—使用dispatch barriers来创建读写索Readers-writer lock。 Dispatch barriers是把一组并发队列操作的函数当做一个串行的阻塞（serial-style bottleneck）。使用GCD的阻塞API是为了确保提交到指定队列的代码块是在特定时间执行的唯一一个任务。这意味所有提交到队列中的任务必须在当前代码块执行完毕时才能够调用。 当轮到下一个代码块执行时，阻塞队列会执行该块并确保队列此时没有执行其他的任务。一旦完成，队列就会返回到默认设置。GCD提供了同步和异步阻塞功能。下图展示了阻塞功能在异步操作时的效果： 值得注意的是在正常情况下队列操作像一个并发队列，当阻塞任务执行时，此时队列更像个串行队列。当前仅仅只有阻塞任务能够执行。当阻塞任务完成时，队列又回到了正常的并发队列中。阻塞功能在什么场合下使用更为恰当： Custom Serial Queue:串行队列下使用并不是一个好的选择，串行操作本身就是一次只能执行一个任务，所以阻塞操作在这里没有起什么作用。 Global Concurrent Queue:在全局并发队列中使用不是个好方法，因为系统操作也可能会使用到这个队列然而你并不希望阻塞系统相关的操作。 Custom Concurrent Queue:对于原子性或者临界区的操作，任何需要线程安全的实例或者操作，阻塞线程都是一个好的选择。既然作为唯一比较好的选择是自定义的并发队列，那么我们就需要自己创建一个处理阻塞的函数并区分读和写的功能。并发队列允许同时进行多个读操作。打卡PhotoManager.m，把下面的私有函数添加到实现类中： 1234@interface PhotoManager ()@property (nonatomic,strong,readonly) NSMutableArray *photosArray;@property (nonatomic, strong) dispatch_queue_t concurrentPhotoQueue; ///&lt; Add this@end 找到addPhoto函数用下面的代码来实现： 1234567891011- (void)addPhoto:(Photo *)photo{ if (photo) { // 1 dispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 [_photosArray addObject:photo]; // 3 dispatch_async(dispatch_get_main_queue(), ^{ // 4 [self postContentAddedNotification]; }); }); }} 下面步骤描述了该函数是如何工作的： 在执行其他操作之前先检查下是否有可用的图片资源。 添加写操作到自定义的队列中，当临界区在执行一个任务时，这个任务会是该队列中唯一一个在执行的。 这段代码是将对象添加到数组中。因为这是一个阻塞块，所以该块永远不会在concurrentPhotoQueue队列中与其他块同时运行。 最后当你添加完图片后发送了一个通知，因为要更新UI界面，所以该通知需要在主线程进行操作。因此这里就在主线程中异步调取了通知操作。 这只是个写操作，你同时需要实现photos读操作和concurrentPhotoQueue的实例化。为了确保同写操作的相关任务的线程安全，你需要在concurrentPhotoQueue队列中执行读操作。并从函数中返回且不能异步调度队列，因为写操作未必会在进行读操作前返回。 在这种情况下dispatch_sync会是一个很好的选择。dispatch_sync()同步提交操作并且会等当前任务完成之后再返回。使用dispatch_sync来跟踪阻塞调度任务，或者在你需要等待相关任务操作完成之后再进行后续操作，此时可以使用dispatch_sync来处理数据。如果是第二种情况，有时你会在dispatch_sync外看到一个__block变量，这个变量是用来处理dispatch_sync函数返回的数据。 值得注意的是，如果你针对当前一个正在运行的串行队列调用dispatch_sync，这将会造成死锁。因为这个操作会等待当前块执行完毕，但当前正在执行的任务又在等待dispatch_sync完成。这就迫使你需要考虑dispatch_sync是从哪个队列中调取的，同时应该放到哪个队列里执行。下面是dispatch_sync使用的环境： Custom Serial Queue:在这种情况下调用要十分小心，如果你针对一个正在运行的队列调用dispatch_sync，这一定会造成死锁的。 Main Queue (Serial):和上边的同样的理由，这种情况也可能会造成潜在的死锁现象。 Concurrent Queue:通过阻塞调度同步执行任务或者等待相关任务完成之后执行后续任务，在这种情况下调用dispatch_sync是完全可以的。 打开PhotoManager.m用下面的代码替换photos方法： 12345678- (NSArray *)photos{ __block NSArray *array; // 1 dispatch_sync(self.concurrentPhotoQueue, ^{ // 2 array = [NSArray arrayWithArray:_photosArray]; // 3 }); return array;} 根据序号查看上面代码的相关解释： __block关键字表示允许对象在块中是可变的，如果没有这个关键字array数组变量在块中是只读属性，根本无法通过编译。 在concurrentPhotoQueue队列中同步调度读取数据。 将图片存储到array中并返回数据。 最后你需要初始化concurrentPhotoQueue队列属性，如下面代码所示： 12345678910111213+ (instancetype)sharedManager{ static PhotoManager *sharedPhotoManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedPhotoManager = [[PhotoManager alloc] init]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; // ADD THIS: sharedPhotoManager-&gt;_concurrentPhotoQueue = dispatch_queue_create(\"com.selander.GooglyPuff.photoQueue\", DISPATCH_QUEUE_CONCURRENT); }); return sharedPhotoManager;} concurrentPhotoQueue的初始化使用的是dispatch_queue_create创建的并发队列。第一个参数是域名地址的方向命名，确保命名描述的清晰性，因为这在调试中会非常有用。第二个参数是指定你的队列是并发的还是串行的。 注意：当在网络上搜索例子时，你经常会看到使用dispatch_queue_create方法创建对队列时第二个参数往往传递的是0或者NULL，这是创建串行队列的一种过时方法，通常是传递更为清晰具体的参数。 Congratulations—PhotoManager单例现在线程安全了，不管你什么时候或者什么地方读取或者写入图片，你完全可以相信这种操作是十分安全的。 回顾队列相关知识点并不是100%确定掌握了GCD的要领？为了确保你已经掌握了基本的要点，请使用GCD函数创建个简单的例子，然后根据断点和NSLog输出，来确保你的确明白了函数在执行过程中发生了什么。 这里提供了两个GIF图片以帮助你巩固对于dispatch_async和dispatch_sync的理解。每个GIF左边显示了代码执行的步骤，右边显示了队列当前的状态。 dispatch_sync知识点再现12345678- (void)viewDidLoad{ [super viewDidLoad];dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ NSLog(@\"First Log\"); }); NSLog(@\"Second Log\");} 主队列中是按顺序执行的任务，将要执行的任务是包含viewDidLoad的UIViewController的实例。 viewDidLoad在主队列中执行。 主线程进入到了viewDidLoad中而且即将执行dispatch_sync。 dispatch_sync添加到了全局队列中并于稍后执行，主线程中的任务停止执行直到dispatch_sync完成操作。同时，全局队列并行处理任务，出现顺序将按照先进先出（FIFO）的顺序，但是执行时会按照并发处理。 全局队列处理在dispatch_sync之前添加到队列中的任务。 最后轮到执行dispatch_sync块。 当dispatch_sync执行完毕，主线程就可以继续执行了。 viewDidLoad执行完毕后，主线程将继续操作后续的任务。 dispatch_sync添加一个任务到队列中并且直到任务执行完毕才会返回。dispatch_async除了不需要等待任务执行完毕才能够执行继续后续任务外，其他流程和上面类似。 dispatch_async知识点再现1234567- (void)viewDidLoad{ [super viewDidLoad]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ NSLog(@\"First Log\"); }); NSLog(@\"Second Log\");} 主线程按顺序执行，下一个将要执行的是含有viewDidLoad方法的UIViewController的一个实例。 viewDidLoad在主线程中执行。 现在主线程在viewDidLoad中执行并且稍后执行dispatch_async方法块。 dispatch_async方法块添加到了全局队列中并且稍后会被执行。 viewDidLoad中的断点会继续移动，dispatch_async添加到全局队列中后主队列依然会继续后续任务的执行。同时全局队列也会并发处理相关任务，记住各个块会以先进先出的顺序出现在全局队列中，但是会并发的执行这些任务。 添加到dispatch_async代码现在开始执行。 dispatch_async执行完毕并且打印相关信息。 在上面这个例子中，第二个NSLog信息出现在第一个NSLog之后。这是由硬件决定在那一刻到底谁先执行，而你是无法确定的，第一个NSLog可能在某些调用中会第一个执行并打印出信息。 下一部分我们将会学习什么呢在这部分教程中，我们学习到了如何使代码线程安全，并且在执行CPU密集型任务时保持主线程的响应能力。你可以下载这个改进后的GooglyPuff Project项目。在第二部分教程中我们将继续改进这个项目。 如果你正在准备优化你的APP，强烈建议使用Instruments中的Time Profile模版分析你的程序。使用此工具已超出本篇教程的范围，但是可以查看这篇文章How to Use Instruments学习下如何使用。同时确保是使用真机进行测试的，因为在模拟器上分析的数据是相当不准确的。 接下来的教程我们将更深入的了解GCD相关的API并做更多更有趣的事。 本篇教程翻译自：Grand Central Dispatch In-Depth: Part ½","link":"/2019/06/16/深入理解GCD-第一部分/"},{"title":"深入理解Grand Central Dispatch:第二部分","text":"欢迎来到第二部分教程，本篇教程我们将更加深入的理解GCD。 在前一篇教程我们学习了并发，线程和GCD是如何运行的。我们使用dispatch_once初始化PhotoManager单例来确保线程安全，通过使用dispatch_barrier_async和dispatch_sync来确保读写Photos时线程安全。除此之外，我们使用dispatch_after控制提示时间，增强了应用的用户体验。同时通过使用dispatch_async来执行CPU密集型任务来提高生成一个视图控制器实例效率。 如果你按步骤学习了上篇教程，你可以重新打开在第一篇教程中的示例工程文件。如果没有的话可以从点击这里下载。 纠正下载提醒框弹出时间或许你已经注意到，当你通过Le Internet来添加图片时，在图片还未下载完时就弹出了提醒框，如下图所示： 这个错误出现在PhotoManagers类中的downloadPhotoWithCompletionBlock:方法中，如下面代码所示：123456789101112131415161718192021222324252627282930313233- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock{ __block NSError *error; for (NSInteger i = 0; i &lt; 3; i++) { NSURL *url; switch (i) { case 0: url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString]; break; case 1: url = [NSURL URLWithString:kSuccessKidURLString]; break; case 2: url = [NSURL URLWithString:kLotsOfFacesURLString]; break; default: break; } Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *_error){ if (_error) { error = _error; } }]; [[PhotoManager sharedManager] addPhoto:photo]; } if (completionBlock) { completionBlock(error); }} 在你认为所有图片已经下载完的地方即在上面这个函数的结尾处调用了completionBlock。关键问题是，你没办法确定所有图片的确是在这个时候下载完的。 当Photo类的实例调用该方法开始下载图片时，在下载完成之前该方法就已经返回了。换句话说，downloadPhotoWithCompletionBlock:在方法结尾处调用completionBlock就好比该函数中的代码都是线性运行的，每个方法都会在前一个方法完成后运行。 然而，-[Photo initWithURL:withCompletionBlock:]是异步的并且会立即返回，所以上面的方法是行不通的。所以，downloadPhotoWithCompletionBlock:应该在所有图片调用他们自己的下载完成的块方法中调用completionBlock。现在的问题是，你如何监控并发的异步事件的，你不知道他们什么时候完成，因为他们可以按任意顺序完成。 也许你可以使用很多的BOOLs跟踪每一个下载，但这是一种相当烂的代码并且非常不易于扩展。幸运的是，Dispatch groups正是为监控多个异步任务完成的情况所设计的。 Dispatch GroupsDispatch groups会在组内所有的任务完成时通知你。这些任务可以是异步的或者同步的甚至可以监控来自不同的队列的任务。当监控不同队列中任务时，dispatch_group_t将会在不同队列中跟踪的不同任务。 当组内的任务完成时，GCD的API提供了两种方式来进行监听。第一种方式是dispatch_group_wait，这个方法是通过阻塞你当前的线程，并且直到组内所有任务完成或者发生超时才会通知你。这种方法或许正是我们所需要的。 打开PhotoManager.m，使用下面的代码来替换downloadPhotosWithCompletionBlock:： 1234567891011121314151617181920212223242526272829303132333435363738- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock{ dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ // 1 __block NSError *error; dispatch_group_t downloadGroup = dispatch_group_create(); // 2 for (NSInteger i = 0; i &lt; 3; i++) { NSURL *url; switch (i) { case 0: url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString]; break; case 1: url = [NSURL URLWithString:kSuccessKidURLString]; break; case 2: url = [NSURL URLWithString:kLotsOfFacesURLString]; break; default: break; } dispatch_group_enter(downloadGroup); // 3 Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *_error) { if (_error) { error = _error; } dispatch_group_leave(downloadGroup); // 4 }]; [[PhotoManager sharedManager] addPhoto:photo]; } dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); // 5 dispatch_async(dispatch_get_main_queue(), ^{ // 6 if (completionBlock) { // 7 completionBlock(error); } }); });} 来看下对每段代码的解释： 当你使用同步方法dispatch_group_wait来阻塞当前进程时，你需要使用dispatch_async来将整个方法放入到后台队列中执行以确保没有阻塞当前的主线程。 这段代码是创建一个调度组好比一个包含很多未完成任务的容器。 dispatch_group_enter手动通知一组任务已经开始，dispatch_group_enter和dispatch_group_leave必须成对调用，否则会导致程序的崩溃。 该处是手动通知组内任务已经完成，同时你需要平衡dispatch_group_enter和dispatch_group_leave的数量。 dispatch_group_wait会在所有任务完成或者超时后执行。如果在所有任务完成前发生了超时，那么这个方法将会返回一个非零值。你可以把这部分放到一个条件块中去检查是否超时，但是在这里我么可以使用DISPATCH_TIME_FOREVER，因为这些图片的下载总是会完成的。 此时你可以确保所有的图片都已经下载完了。然后回到主线程调用该方法的completionBlock。主线程会在稍后执行该部分代码。 最后检查completionBlock是否为空，如果不为空就返回。 编译并运行程序，尝试下载多张图片并注意观察程序是如何处理图片下载完成后的操作的。 注意：如果你在真机上运行而且网络速度很快以至于没有观察到完成后的操作，你可以通过调节在设置中的开发者选项，选择非常糟糕的网速来进行查看。 如果你是在模拟器上运行，可以通过这个（network link conditioner）来改变网速。这是个很好的工具并且会迫使你去考虑网速不好的情况下程序运行状态。 这个解决方案已经很不错了，但是通常在允许的情况下我们会尽量避免阻塞线程的。你下面的任务是重写这个方法并在所有的下载任务完成时进行异步通知。 在我们开始使用另外一种dispatch groups时，先简要说明下在各种队列中调用dispatch groups相关指南： Custom Serial Queue:当组内任务完成时，在该队列中进行通知是个很好的选择。 Main Queue (Serial):这也是个不错的选择，但是在同步等待任务完成时你应该小心避免阻塞主线程。然而在等待例如网络连接一些长任务完成时，异步模型对于更新UI界面是个不错的选择。 Concurrent Queue:这个对于调用dispatch groups并获取完成时的通知同样是个不错的选择。 第二种Dispatch groups方法上一个方法已经很好了，但是有些麻烦我们不得不异步调度到另一个队列中然后使用dispatch_group_wait阻塞线程。这里还有另外一个办法： 使用下面的代码替换PhotoManager.m文件中的downloadPhotosWithCompletionBlock:方法 123456789101112131415161718192021222324252627282930313233343536- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock{ // 1 __block NSError *error; dispatch_group_t downloadGroup = dispatch_group_create(); for (NSInteger i = 0; i &lt; 3; i++) { NSURL *url; switch (i) { case 0: url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString]; break; case 1: url = [NSURL URLWithString:kSuccessKidURLString]; break; case 2: url = [NSURL URLWithString:kLotsOfFacesURLString]; break; default: break; } dispatch_group_enter(downloadGroup); // 2 Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *_error) { if (_error) { error = _error; } dispatch_group_leave(downloadGroup); // 3 }]; [[PhotoManager sharedManager] addPhoto:photo]; } dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4 if (completionBlock) { completionBlock(error); } });} 下面是代码运行步骤说明： 在这个新方法中你不需要把代码放到异步调用块中，因为你不需要阻塞主线程。 这个是enter方法，和上个方法调用的一样。 这个是leave方法，也和之前的一样。 dispatch_group_notify作为最终的异步完成块进行调用。这部分代码是在调度组内任务都完成后才运行completion block的。你也可以选择在其他队列中调用完成块代码，这里是在主线程运行的。这个方法更简明易懂而且没有阻塞任何线程。 大量并发的危险性这些新方法都掌握后，你是不是想在项目各个地方都使用线程呢？ 再看下PhotoManager中的downloadPhotosWithCompletionBlock方法，你可能注意到有个for循环，通过循环三次来下载三张不同的图片。你现在的任务时能否使这个for循环并发执行并提高它的运行速度。 dispatch_apply这时就该上场了。dispatch_apply就像for循环一样可以并发执行不同的循环。这个方法是同步的，所以就像一个正常的for循环一样，只有在所有的任务都完成时dispatch_apply才会返回。 值得注意的是，对于在块中的任务我们需要指定明确适当的循环次数，因为多次循环的少量任务会导致很大的开销而并没有因并发调用而获取什么好处。被称作striding（跨越式）的技术可以帮助你，这里就是你在每个循环需要做的任务。——该处翻译有问题请查看原文 什么时候调用dispatch_apply更合适呢？ Custom Serial Queue:串行队列是完全不能适合使用dispatch_apply的，使用for循环就可以了。 Main Queue (Serial):如上文所示，在串行队列中使用dispatch_apply并不是个好主意，使用for循环即可。 Concurrent Queue:在并发循环更适合调用，尤其是当你跟踪任务任务进程时。 回到downloadPhotosWithCompletionBlock方法中并用下列代码替换： 1234567891011121314151617181920212223242526272829303132333435- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock{ __block NSError *error; dispatch_group_t downloadGroup = dispatch_group_create(); dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) { NSURL *url; switch (i) { case 0: url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString]; break; case 1: url = [NSURL URLWithString:kSuccessKidURLString]; break; case 2: url = [NSURL URLWithString:kLotsOfFacesURLString]; break; default: break; } dispatch_group_enter(downloadGroup); Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *_error) { if (_error) { error = _error; } dispatch_group_leave(downloadGroup); }]; [[PhotoManager sharedManager] addPhoto:photo]; }); dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ if (completionBlock) { completionBlock(error); } });} 现在的循环就是并发调用了，在上面的代码中在调用dispatch_apply时，第一个参数需要指定循环次数，第二个参数指定在那个队列中执行，第三个参数执行循环任务。尽管添加图片的代码是线程安全的，但是图片添加完成顺序则取决于相关线程完成顺序。 编译并运行，使用Le Internet添加图片，是否注意到有什么不同么？有时在设备上运行这段代码会感觉更快，但是真的值得这样做么？实际上，在上面这个例子中并不建议这样使用： 相对于for而言，使用并发线程运行可能会产生很多开销。dispatch_apply应该在遍历非常大的集合而且集合中的任务不是那么复杂的情况下使用。 启动程序的时间是有限的，不要在你不了解的代码上浪费时间去进行优化。如果你要优化的代码的好处是显而易见的，那么就值得你去优化。通过运行Instruments来分析你的应用找出最耗费资源的方法。通过这篇文章了解更多How to Use Instruments in Xcode。 通常来讲优化代码使你或者后来看你代码的人会感觉更为复杂，请确保程序中添加并发处理的确有必要而且是有意义的。 记住不要疯狂的对代码进行无意义的优化，这样只会使你或者后来读你代码的人感到更加困惑。 其他有趣的GCD方法但是等等，这里还有更多另辟蹊径的方法，尽管你不会经常使用这些方法，但是在适当情况下使用会对你的程序有很大的帮助。 阻塞-正确的方式这听起来像个疯狂的想法，但是你知道Xcode有测试功能么？我知道有时我们并不经常使用他们，但是对于复杂的逻辑代码写测试用例还是很有必要的。 通过运行Xcode上的XCTestCase子类文件中以test*开头的方法来进行测试。测试方法是在主线程中执行的，这样你就可以假设所有的测试方法是以串行方式运行的。 一旦一个给定的测试方法执行完毕，XCTest就会认为这条测试已经完成并且会继续执行下一条测试。这就意味着在执行下条测试时上条测试的异步代码仍在继续执行。 网络连接相关的代码通常是异步的，如果在执行网络连接时你没有阻塞阻塞主线程，那就意味着当测试方法执行完时很难再对网络相关的代码进行测试。除非你在测试方法中阻塞主线程直到网络连接完成。 有些人或许认为这种测试方法并不属于集成测试中的优先选择，一些人同意，一些人则不同意。但是如果这样做是有用的，那就可以使用这种方法。 回到GooglyPuffTests.m文件中，找到downloadImageURLWithString方法，使用下面代码进行替换： 1234567891011121314- (void)downloadImageURLWithString:(NSString *)URLString{ NSURL *url = [NSURL URLWithString:URLString]; __block BOOL isFinishedDownloading = NO; __unused Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *error) { if (error) { XCTFail(@\"%@ failed. %@\", URLString, error); } isFinishedDownloading = YES; }]; while (!isFinishedDownloading) {}} 这是一种很幼稚的方法来测试异步网络代码。在方法末尾的while循环直到isFinishedDownloading布尔值变为true时即执行completion block时才会退出。让我们来看看这样做会什么样的影响。 点击菜单栏Product / Test或者⌘+U来运行测试代码。 在运行测试时，注意观察调试导航栏中显示的CPU的运行情况。这种不当的实现方式被称作自旋锁（spinlock）。这种实现方式是不合理的，你不仅在浪费CPU宝贵的时间-在等待while循环的结束，也无法很好的对这段代码进行扩展。 你或许可以使用前面我们介绍过的网络连接适配器-network link conditioner来进行调试，你会更容易发现这个问题。如果你的网络速度足够快卡顿也只会发生一会儿。你需要一个更优化的，可扩展的方法来阻塞线程直到资源变为有效。信号量-Semaphores或许是个不错的选择。 Semaphores-信号量信号量在学校时教授Edsger W. Dijkstra相关理论时的一种线程概念。信号量是个复杂的概念，因为他们是建立在复杂的操作系统功能之上的。 如果你想了解关于信号量的更多知识，可以点击这里link which discusses semaphore theory in more detail。如果你是学术派，那肯定了解使用信号量解决的一个经典的软件开发问题-哲学家就餐问题Dining Philosophers Problem。 你可以通过信号量来控值多个消费者访问有限的资源。例如，如果你创建了一个拥有两个资源池的信号量，通常情况下只能够使两个线程同时访问这个临界区，另外想使用资源的线程必须等待，这就是先进先出队列。 来让我们一起使用信号量。打开GooglyPuffTests.m文件并使用下列代码替换downloadImageURLWithString函数： 1234567891011121314151617181920- (void)downloadImageURLWithString:(NSString *)URLString{ // 1 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); NSURL *url = [NSURL URLWithString:URLString]; __unused Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *error) { if (error) { XCTFail(@\"%@ failed. %@\", URLString, error); } // 2 dispatch_semaphore_signal(semaphore); }]; // 3 dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW,kDefaultTimeoutLengthInNanoSeconds); if (dispatch_semaphore_wait(semaphore, timeoutTime)) { XCTFail(@\"%@ timed out\", URLString); }} 下边是对上面代码执行步骤的解释： 创建信号量。传递的参数是用来指定信号量开始时间，这个参数值可以通过信号量来控制，而不必去管理这个数字的递增。（注意信号量的递增即为发送信号） 在completion block中你告诉信号量不需要资源了，这就增加了信号量的计数并告诉其他信号量这个资源是可用的。 在给定的时间内等待信号量的返回，这段代码将阻塞线程直到接收到信号为止。但不为0的数字返回时就意味着超时了。在这个例子中，如果测试用例失败可能是因为网络超过10s才返回。 重新运行测试，只要网络正常应该就能够测试成功。注意查看CPU消耗情况并和前面的进行对比。断开网络连接并再次进行测试，如果是在真机上运行，直接调成飞行模式就可以了。在模拟器上则需要关掉网络，在10s之后这个测试失败了。 这些都是相当繁琐的测试，但是如果你在一个团队中工作，这些基本的测试能够指出网络发生问题是到底谁应该负这个责任。 使用Dispatch SourcesGCD一个特别有趣的功能就是Dispatch Sources，这是一个非常底层的函数主要是用来帮助你监听Unix信号，文件描述，Mach端口，VFS节点等一些晦涩难懂的东西。所有的这些都已经超过了这篇教程的范围，但是你可以通过一种特别的方式来浅层次调用dispatch source对象。 第一次使用dispatch sources的用户可能对如何调用感到很疑惑，所以首先你要明白dispatch_source_create是如何工作的，下面是创建的函数原型： 12345dispatch_source_t dispatch_source_create( dispatch_source_type_t type, uintptr_t handle, unsigned long mask, dispatch_queue_t queue); dispatch_source_type_t是个很重要的参数，他决定了使用什么句柄和掩码参数。你需要到开发文档中去查看dispatch_source_type_t每种类型的含义。 你将监听DISPATCH_SOURCE_TYPE_SIGNAL参数类型，如文档中描述 一个调度源监听当前进程的信号，句柄是一个信号编号（int）。掩码没有使用（传0值）。这些Unix信号列表可以在signal.h文件中查看。在文件头部有一串#define。在这些信号中，你将监听SIGSTOP信号，当收到一个无法回避的挂起指令时，该信号将会发出。当你使用LLDB调试程序时该信号同样会被发出。 到PhotoCollectionViewController.m文件中将下列方法添加到viewDidLoad中： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad{ [super viewDidLoad]; // 1 #if DEBUG // 2 dispatch_queue_t queue = dispatch_get_main_queue(); // 3 static dispatch_source_t source = nil; // 4 __typeof(self) __weak weakSelf = self; // 5 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 6 source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, queue); // 7 if (source) { // 8 dispatch_source_set_event_handler(source, ^{ // 9 NSLog(@\"Hi, I am: %@\", weakSelf); }); dispatch_resume(source); // 10 } }); #endif // The other stuff 这段代码有点繁琐，所以通过注释来看看代码是如何执行的： 最好在DEBUG模式下来编译这段代码。 通过dispatch_queue_t来创建实例变量而不是直接在在参数部分提供这个函数，当代码变得很长时，分开赋值可能更具有可读性。 source会在方法外重复调用，所以你需要个静态变量。 使用weakSelf来确保不会陷入循环引用。对于PhotoCollectionViewController并不是完全有必要的，因为在app的整个生病周期中它是始终驻守在内存中的。但是如果有什么类被销毁了，仍需这样做来确保循环引用。 使用dispatch_once对调度源只创建一次。 这是source变量初始化方法，你需要指定对信号监听感兴趣并且给第二个参数赋值SIGSTOP，另外需要使用主队列来接收事件。 如果你提供的参数格式不正确dispatch source对象是不会被创建的，所以你在调用之前你要确保该对象是可用的。 当你监听到你接收到的信号时dispatch_source_set_event_handler就会被调用。然后在block参数中写入相应的逻辑。 这是在终端打印类型相关的信息。 默认情况下，所有创建的资源是挂起状态。所以当你在监听事件时，需要告诉源对象恢复状态。 编译并运行程序，在调试部分暂停了一会儿，但是立刻又恢复了app运行状态。查看终端输出，你会发现函数确实运行了，如下面代码所示： 2014-03-29 17:41:30.610 GooglyPuff[8181:60b] Hi, I am: 但是在app运行周期应该如何调用呢？ 每当您恢复应用程序状态时可以使用此方法来调试相关对象并打印信息。当恶意攻击者将调试器附加到你的应用上时，你也可以调用自定义安全逻辑来保护你的程序。一个很有趣的想法就是通过使用此方法来跟踪堆栈相关信息，并发现你在调试器中操纵的对象。 想一想这种情况，当你在断点外运行时，你几乎看不到你所需要的堆栈信息。现在你可以在任何时间调试，并在你设计的地方执行相关代码。相对于调试器繁琐操作而言，对于在程序某个地方用此方法进行调试是非常有用的。 在viewDidLoad句柄中的NSLog处添加断点。程序在DEBUG处暂停，然后再次运行时，程序会暂停到断点处。此时已经运行到了PhotoCollectionViewController类的底层，你可以访问PhotoCollectionViewController类的核心方法了。 如果你还不知道哪个线程在调试器中，现在就看看。在libdispatch之后主线程总会是第一个出现，GCD线程会在第二个出现。当程序遇到断点时，线程数和线程保留数依赖于硬件当时在做什么。 在调试器中，输入下面的代码 po [[weakSelf navigationItem] setPrompt:@“WOOT!”] 然后继续执行程序，会看到如下图所示： 通过这种方法，你不仅可以更新UI，而且可以查询类的属性，甚至执行方法。所有这些操作都不需要通过重新启动App来获取当前更改后的状态。真的是非常好用。 接下来学习什么你可点击这个地址下载示例程序。 我很讨厌再次重复之前强调的东西，但是你真的应该去学习这篇教程How to Use Instruments。如果你准备对你的程序进行优化，这个工具是必不可少的。Instruments很擅长分析不同代码执行的效率：对比不同代码之间花费时长。如果想知道某个方法的确切执行时间，那就需要你自己写方法来完成这个计算。 同时查看这篇教程 How to Use NSOperations and NSOperationQueues，是建立在GCD之上的一种并发处理技术。通常情况下对于简单的并发任务使用GCD已经足够了，但是对于大量并发操作的实现和使用一种更接近于面向对象编程模式，NSOperations会更好。 请记住，除非你有特别的需要才能会去使用底层API，否则就要坚持使用更高层的API。只有进入苹果的黑魔法领域，你才能够学到更多或者做到更多有趣的事。 翻译自Grand Central Dispatch In-Depth: Part 2/2","link":"/2019/06/17/深入理解GCD-第二部分/"}],"tags":[{"name":"GCD","slug":"GCD","link":"/tags/GCD/"},{"name":"多线程","slug":"多线程","link":"/tags/多线程/"}],"categories":[]}